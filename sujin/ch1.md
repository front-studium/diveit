## 1. 동등 비교

- 리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나: props의 동등 비교에 따른 결과
  - 프롭스의 동등 비교는 객체의 얕은 비교를 기반으로 이뤄짐
- 가상 DOM, 실제 DOM의 비교, 리액트 컴포넌트가 렌더링할지를 판단하는 방법, 변수나 함수의 메모이제이션 등의 모든 작업은 동등 비교를 기반으로 함.

### 1. 데이터 타입

- 원시타입
  - boolean: 참과 거짓만을 가질 수 있는 데이터 타입. truthy, falsy한 값이 존재
  - null: 아직 값이 없거나 비어있는 값
  - undefined : 선언후 값을 할당하지 않은 변수, 인수에 자동으로 할당되는 값
  - number
  - string: 텍스트 타입의 데이터를 저장하기 위해 사용. ’, “, `(백틱) 으로 표현 가능
    - 템플릿 리터럴 : 백틱을 사용해 표현한 문자열. 줄바꿈 가능, 문자열 내부에 표현식 쓸 수 있음
    - 특징 : 변경 불가능한 원시타입. ⇒ 변경할 수 없음
  - symbol : ES6에서 새롭게 추가된 타입. 중복되지 않는 어떤 고유한 값을 나타내기 위해 만들어짐.
  - bigint: 기존 숫자형이 다룰 수 있는 숫자 크기의 제한을 극복하기 위해 ES2020에서 새로 나온 타입.
- 객체타입
  - object( 원시타입 이외에 모든 것)
    - 참조를 전달한다고 해서 참조 타입으로 불림.

### 2. 값을 저장 하는 방식의 차이

- 값을 저장하는 방식의 차이가 동등 비교시 차이를 만드는 원인이 됨

### 3. 다른 비교공식 Object.is

- == vs [Object.is](http://Object.is) : == 비교는 양쪽 타입이 다르면 강제 형변환 후 비교. Object.is는 강제형변환 하지 않음.
- === vs [Object.is](http://Object.is) : Object.is가 좀 더 개발자가 기대하는 방식으로 정확히 비교
- 주의할 점: Object.is를 사용해도 객체 비교에는 별 차이가 없음.

### 4. 리액트에서의 동등 비교

리액트에서 사용하는 동등 비교는 [Object.is](http://Object.is). 이것은 ES6에서 제공하는 기능이기 때문에 폴리필을 함께 사용

- 폴리필이란?

리액트에서는 이 [Object.is](http://Object.is) 를 기반으로 동등비교를 하는 shallowEqual 함수를 만들어 사용.

이 함수는 의존성 비교 등 리액트의 동등 비교가 필요한 곳에서 사용됨

- 비교하는 순서
  - Object.is로 비교 수행 ⇒ 객체 간 얕은 비교 한번 더 수행

## 2. 함수

### 1. 함수란?

작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸 실행단위로 만들어 놓은 것

리액트에서 컴포넌트를 만드는 함수도 이러한 기초적인 형태를 따름.

### 2. 함수를 정의하는 4가지 방법

- 함수 선언문
  - 표현식이 아닌 일반 문(statement)
  - 코드의 문맥에 따라 자바스크립트 엔진이 동일한 함수를 표현식으로 해석하는 경우가 있음.
- 함수 표현식
  - 일급 객체 : 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체
  - 자바스크립트에서 함수는 일급 객체 ⇒ 매개변수, 반환값이 될수 있고, 할당 가능하기 때문
- 함수 표현식과 선언식의 차이
  - 호이스팅 여부
    - 함수 선언문이 코드 맨 앞단에 작성된 것처럼 작동하는 것.
      함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업을 의미한다.
      함수 표현식은 호이스팅 되는 시점에서 var의 경우 undefined로 초기화한다는 차이가 있음
- 어떤 것이 좋을까?
  - 함수를 자유롭게 선언, 명시적으로 함수를 구별하고 싶다 ⇒ 함수 선언문
- Function 생성자
  - 매개 변수, 함수의 몸통을 모두 문자열로 작성해야 함
- 화살표 함수
  - 타이핑할 글자 수가 줄어들어 많이 사용됨
  - 화살표 함수에서는 constructor를 사용할 수 없음
  - arguments가 존재하지 않는다 ⇒ ? 호출할때 잘 argument 넣어서 사용하지 않았나..?
  - this 바인딩의 차이: 함수 자체의 바인딩을 갖지 않아서 함수 내부에서 this 참조 시 상위 스코프의 this를 그대로 따르게 됨.

### 3. 다양한 함수 살펴보기

- 즉시 실행 함수 : 한번만 실행되고 다시 호출할 수 없는 함수
- 고차 함수 : 함수를 인수로 받거나 결과로 새로운 함수를 반환시키는(일급객체의 특징을 활용한) 함수. 이러한 특징을 활용해 함수 컴포넌트를 인수로 받아 새로운 함수 컴포넌트를 반환하는 고차 함수(고차 컴포넌트)를 만들 수 있음. ⇒ 컴포넌트 내부에서 공통으로 관리되는 로직을 분리해 관리할 수 있음

### 4. 주의사항

- 함수의 부수효과 최대한 억제하기
- 가능한 한 함수를 작게 만들기
- 누구나 이해할 수 있는 이름을 붙이기

## 3. 클래스

### 1. 클래스란?

- 특정한 개체를 만들기 위한 일종의 템플릿과 같은 개념
- 클래스를 활용하면 객체를 만드는데 필요한 데이터나 이를 조작하는 코드를 추상화해 객체 생성을 편리하게 할 수 있음
- constructor : 생성자, 객체를 생성하는데 사용하는 특수한 메서드. 단 하나만 존재할 수 있으며 생성자에서 수행할 별다른 작업이 없다면 생략 가능
- 프로퍼티: 클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값
  - 타입스크립트에서 private, protected, public을 사용할 수 있지만 기본적으로 모든 프로퍼티는 public
- getter와 setter : 클래스에서 값을 가져올 때 사용
  - getter 사용 ⇒ get ~~(getter이름 선언)
  - setter 사용 ⇒ set ~~(setter 이름 선언)
- 인스턴스 메서드 : 클래스 내부에서 선언한 메서드. 프로토타입 메서드로 불리기도 함
- 프로토타입 확인하기
  - Object.getPrototypeOf
  - `__proto__` : 가급적 사용하면 안됨. 호환성을 지키기 위해서만 존재하는 기능이기 때문
  - 프로토타입 체이닝 : 객체에서 직접 선언하지 않아도 프로토타입에 있는 메서드를 찾아 실행을 도와주는 것. 자기자신 ⇒ Object(최상위객체) 까지 훑음. 비슷한 원리로 동작하는 메서드로 toString이 있음.
- 정적 메서드 : 클래스의 이름으로 호출할 수 있는 메서드
  - 정적 내부의 this : 사용 불가 ⇒ static getDerivedStateFromProps(props, state) 에서도 접근할 수 없음.
- 상속
  - extends: 기존 클래스를 상속받아 자식 클래스에서 상속받은 클래스를 기반으로 확장하는 개념

### 2. 클래스와 함수의 관계

- 클래스 작동을 생성자 함수로 유사하게 재현할 수 있음.
- 클래스는 문법적 설탕의 역할을 함.
- 클래스는 프로토
- 타입을 기반으로 작동

## 4. 클로저

### 1. 정의

- 함수와 함수가 선언된 어휘적 환경(Lexical Scope)의 조합
  변수가 코드 내부에서 어디서 선언됐는지를 말하는것

### 2. 스코프

- 전역 스코프 : 전역 레벨에 선언하는것
  - 브라우저 환경에서 전역객체는 window, node.js환경에서는 global 객체에 바인딩
- 함수 스코프
  - 기본적으로 함수 레벨 스코프를 따름. {} 블록이 스코프를 결정하지 않음

### 3. 클로저의 활용

- 전역 스코프 : 어디서든 원하는 값을 꺼내올 수 있음 ⇒ 누구나 망가뜨릴 수 있음
- 내부 상태값을 리액트가 별도로 관리하는 클로저 내부에서만 접근 가능
- 리액트에서의 클로저
  - useState
    - useState 내부의 최신값을 setState가 확인 할 수 있는 이유는 클로저가 useState내부에서 활용되었기 때문

### 4. 주의할 점

- 기본 개념을 주의깊게 살펴봐야 클로저를 제대로 활용할 수 있음
- 클로저를 사용하는데는 비용이 듦

## 5. 이벤트 루프와 비동기 통신의 이해

- 자바스크립트는 싱글스레드에서 동기방식으로 작동하지만 많은 양의 비동기 작업이 이뤄짐.

### 1. 싱글 스레드

- 프로세스: 프로그램을 구도앻 프로그램의 상태가 메모리 상에서 실행되는 작업 단위
- 스레드 : 프로세스보다 더 작은 실행단위
- 자바스크립트의 모든 코드는 동기식으로 한번에 하나씩 순차적으로 처리됨

### 2. 이벤트 루프

- 이벤트루프: 자바스크립트 런타임 외부에서 자바스크립트 비동기 실행을 돕기 위해 만들어진 장치
- 호출 스택과 이벤트 루프
  - 호출 스택: 자바스크립트에서 수행해야할 코드나 함수를 순차적으로 담아두는 스택
  - 이벤트 루프: 호출 스택이 비어있는지 여부를 확인하고, 태스크 큐에 대기중인 함수가 있는지 반복해서 확인하는 역할을 함.
  - 태스크 큐 : 실행해야할 태스크의 집합
  - 비동기 함수는 누가 수행하는가 ⇒ 태스크 큐가 할당되는 별도의 스레드에서 수행

### 3. 태스크 큐와 마이크로 태스크 큐

- 이벤트 루프는 하나의 마이크로 태스크 큐를 가지며, 기존의 태스크 큐와는 다른 태스크를 처리함.
- 렌더링은 마이크로 태스크큐를 실행한 뒤에 일어남.

## 6. 리액트에서 자주 사용하는 자바스크립트 문법

### 1. 구조분해할당

- 배열 구조 분해 할당
  - ,의 위치에 따라 값이 결정됨.
  - … 을 사용하면 나머지 모든 값을 해당 변수에 배열로 넣게 됨
- 객체 구조 분해 할당 : 객체에서 값을 꺼내온뒤 할당 하는 것
  - 배열 구조 분해 할당과 달리 객체는 객체 내부 이름으로 꺼내옴

### 2. 전개구문

- 구조 분해 할당과는 다르게 배열이나 객체, 문자열과 같이 순회할 수 있는 값에 대해 전개해 간결하게 사용할 수 있는 구문
- 배열의 전개 구문
- 객체의 전개 구문

### 3. 객체 초기자

객체를 선언할 때 객체에 넣고자 하는 키와 값을 가지고 있는 변수가 이미 존재한다면 해당 값을 간결하게 넣어줄 수 있는 방식

### 4. Array 프로토타입의 메서드(map, filter, reduce, forEach)

- Array.prototype.map
  - 인수로 전달받은 배열과 똑같은 길이의 새로운 배열을 반환하는 메서드
- Array.prototype.filter
  - 콜백함수를 인수로 받으며, 이 콜백함수에서 truty 조건을 만족하는 경우에만 해당 원소를 반환
- Array.prototype.reduce
  - 콜백함수와 함께 초킷값을 추가로 인수를 받아 이 초깃값에 따라 배열, 객체 또는 그 외의 다른 무언가를 반환할 수 있는 메서드.
- Array.prototype.forEach
  - 콜백 함수를 받아 배열을 순회하면서 단순히 그 콜백함수를 실행하기만 하는 메서드. 아무런 반환값이 없으며, 에러를 던지거나 프로세스를 종료하지 않는 이상 멈출수 없음.

### 5. 삼항 조건 연산자

자바스크립트에서 유일하게 3개의 피연산자를 취할 수 있는 문법. 리액트에서 자주 쓰이며. 특히 JSX내부에서 조건부로 렌더링 하기 위해 가장 널리 쓰이는 방법. 하지만 가급적 중첩해서 쓰지 않는 편이 좋음
