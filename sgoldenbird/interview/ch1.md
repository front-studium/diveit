#### 리액트의 장점이 무엇인가요?

- 선언적이고 컴포넌트 기반
  상태만 정의하면 React가 자동으로 UI를 최신 상태로 갱신해 주기 때문에 코드가 단순해지고, 컴포넌트 단위로 재사용과 유지보수가 용이
- 단방향 데이터 흐름 - 상태 관리가 예측 가능하고, 버그 추적이 용이
- JSX는 자바스크립트 문법에 HTML을 약간 가미한 수준이라 입문하기 비교적 쉬움
- 가상 DOM을 이용해 필요한 부분만 효율적으로 업데이트하기 때문에 성능 면에서도 이점
- 방대한 생태계와 커뮤니티가 있어 다양한 자료나 라이브러리를 활용할 수 있음

#### 함수형 프로그래밍이란?

- 프로그램을 순수 함수의 조합으로 구성하고, 데이터를 불변하게 다루며, 부수효과를 최소화하는 프로그래밍 패러다임
- 같은 입력에는 항상 같은 출력이 보장되도록 하고, 공유된 상태를 변경하지 않아 예측 가능성이 높음
- 자바스크립트에서 map, filter, reduce 같은 고차 함수를 활용하는 방식이 대표적인 함수형 프로그래밍 스타일

#### 좋은 함수는 어떤 함수인가요?

- 부수 효과가 최소화 되어있고
- 하나의 함수가 너무 많은 역할을 하지 않으며
- 역할에 적합한 이름을 가진 함수

#### 자바스크립트에서 == 와 ===, Object.is 가 어떻게 다른지 설명해 주세요.

- == 느슨한 비교, 두 값의 타입이 다르면 먼저 암묵적 형 변환(강제 형 변환)
- ===는 엄격한 비교,타입 변환 없이 값과 타입이 모두 같아야만 true를 반환
- 실무에서는 암묵적 형 변환이 예측하기 어려운 버그를 만들 수 있어서 보통 ===를 사용하는 게 권장
- ES6부터는 `Object.is`라는 비교 방법도 추가됐는데, `NaN`이나 `+0`, `-0` 같은 특수 케이스까지 더 엄밀하게 구분할 수 있다.

#### 자바스크립트에서 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)에 대해 설명해 주세요.

- 자바스크립트에서 값을 복사할 때는 자료형에 따라 차이가 있다.
- 기본형 값은 실제 값 자체가 복사되기 때문에 서로 독립적

- 객체 같은 참조형은 메모리 주소가 복사되므로, 한 쪽을 바꾸면 다른 쪽도 함께 바뀜

  - 참조형을 복사할 때 메모리 주소만 복사되는 것을 얕은 복사,
  - 내부 값까지 새로 만들어 원본과 완전히 분리하는 것을 깊은 복사

- 참조형의 경우, 얕은 복사는 `Object.assign`이나 스프레드 연산자(`...`)로 할 수 있지만, 중첩된 객체까지는 복사하지 못함. (객체나 배열의 첫번째 레벨만 복사하고 중첩된 객체는 원본과 참조를 공유)
- 참조형의 깊은 복사는 `JSON.stringify` 후 `JSON.parse` 같은 방법, 직접 재귀 함수를 짜는 방법, 혹은 Lodash 같은 라이브러리를 활용. (객체의 모든 중첩된 구조를 독립적으로 복사해 원본과 복사본은 완전히 독립적인 객체)

- 실무에서는 얕은 복사를 주로 쓰지만, 원본과 완전히 독립된 데이터가 필요할 때 깊은 복사를 사용.

#### 호이스팅에 대해 설명해주세요.

- 호이스팅은 JavaScript 엔진이 코드를 실행하기 전에, 즉 런타임 전에 변수와 함수의 선언을 해당 스코프의 최상단으로 끌어올리는 것처럼 동작하는 현상.

  - 함수 호이스팅은 함수 선언문이 마치 코드 맨 앞단에 작성된 것처럼 작동. 함수에 대한 선언을 실행 전에 미리 메모리에 등록하기 때문에 실행 전에도 호출 가능.
  - 변수 호이스팅은 함수 표현식으로 함수를 정의한 경우 발생.
    - var의 경우 호이스팅 되면서 undefined로 초기화, 선언 전 호출 가능. let, const는 TDZ존재, 선언 전에 호출하면 에러.

- **호이스팅이 왜 일어나는가**
  - 자바스크립트 엔진이 코드를 실행하기 전에 실행 컨텍스트를 생성하면서, 변수와 함수 선언을 먼저 메모리에 등록하기 때문에 발생
  - 즉, 호이스팅은 실행 컨텍스트의 생성 단계에서 렉시컬 환경에 선언이 먼저 기록되기 때문에 나타나는 현상

#### var, let, const 비교

- 자바스크립트에서 var, let, const는 모두 변수 선언에 사용되는 키워드
- 스코프 측면에서 var는 함수 스코프만 인식하기 때문에 블록({ }) 안에서 선언해도 바깥에서 접근가능
  반대로 let과 const는 블록 스코프를 가지기 때문에 해당 블록을 벗어나면 접근불가
- 중복 선언 관점에서는 var는 같은 스코프에서 여러 번 선언해도 에러가 나지 않고 마지막 값만 유효. 반면 let과 const는 같은 스코프에서 중복 선언이 불가능
- 호이스팅 관점에서 세 가지 모두 변수 호이스팅은 되지만 var는 선언 전에도 호출 할 수 있고 값은 undefined로 나온다. 반면 let과 const는 일시적 사각지대(TDZ)가 생겨 선언 전에 호출하면 에러.
- var는 오래된 방식이라 의도치 않은 버그를 만들 수 있고, 실무에서는 대부분 let과 const를 사용
- let과 const의 차이는 변경이 필요 없는 값은 const, 변경될 수 있는 값은 let으로 선언하는 게 일반적.
- const로 선언한 변수는 반드시 선언과 동시에 초기화 해야하고 재할당 금지. 반면 let은 선언과 초기화를 따로 해도 되고 재할당이 자유로움.

#### 자바스크립트 this에 대해 설명해주세요.

- 자바스크립트에서 this는 함수가 실행될 때 ‘누가 이 함수를 호출했는지’에 따라 동적으로 결정되는 자기 참조 변수
- 전역에서 일반함수로 호출하면 this는 전역 객체
- 객체의 메서드로 호출하면 호출한 그 객체
- new 키워드로 호출하면 새로 생성된 인스턴스
- 또 이벤트 핸들러에서는 이벤트가 발생한 DOM 요소
- 화살표 함수는 조금 다른데, 호출 방식과 무관하게 선언될 당시 상위 스코프의 this를 그대로 사용
- `bind`, `call`, `apply` 같은 메서드로 원하는 객체에 명시적으로 this를 바인딩할 수도 있다.

#### 렉시컬 스코프에 대해 설명해주세요.

- 렉시컬 스코프는 함수를 어디서 호출했는지가 아니라 선언된 위치를 기준으로 변수의 범위가(스코프가) 결정되는 것.
- 자바스크립트는 정적 스코프 언어

#### 클로저가 무엇인지 그리고 JavaScript에서 어떤 경우에 활용하면 좋을지 예시와 함께 설명해주세요.

- 함수가 자신이 선언된 시점의 환경을 기억해서, 함수가 실행될 때 그 환경에 접근할 수 있게 해주는 개념
  쉽게 말하면, 함수가 끝나도 그 안의 변수를 계속 기억할 수 있는 기능

클로저를 활용하면

- 전역 스코프의 사용을 막고 개발자가 원하는 정보만 개발자가 원하는 방향으로 노출시킬 수 있다.
- 외부에서는 직접 접근하지 못하게 하고, 특정 함수로만 접근하도록 만들어 보안을 강화할 수 있고 정보 은닉이 가능
- useState도 클로저의 대표적인 예 입니다. state가 저장돼 있는 어딘가를 기억하기 때문에 계속 state값 사용 가능.
- 함수형 프로그래밍에서 고차 함수 패턴으로 자주 구현 됩니다. (함수를 반환하거나 인자로 전달할 때)
- 주의할 점은 클로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 추가 비용이 든다. (메모리 저장 용량에 영향). 적절한 스코프로 가둬야함.

#### 스레드에 대해 설명해주세요.

- 스레드는 CPU가 작업을 수행하는 실행단위
- 하나의 프로세스에는 여러 개의 스레드를 만들 수 있고 스레드끼리는 메모리를 공유할 수 있어서 여러 작업을 동시에 수행할 수 있다.

멀티 스레딩 환경에서는 주의해야할 점

- 동시에 서로 같은 자원에 접근해 여러번 수정하는 등 동시성 문제
- 하나의 스레드에 문제가 생기면 같은 자원을 공유하는 다른 스레드에도 문제가 발생

자바스크립트는 싱글스레드

- Node.js의 Worker나 브라우저의 WebWorker를 활용하면 멀티스레드 작업을 할 수 있다.

#### 동기와 비동기에 대해 설명해주세요.

- 동기와 비동기는 작업을 처리하는 순서에 관한 개념
  동기는 코드가 작성된 순서대로 실행되며, 한 작업이 끝나야 다음 작업을 처리. 그래서 응답이 늦어지면 전체 흐름이 막힘.
  비동기는 응답을 기다리지 않고 다음 작업을 바로 진행. (이후 결과가 준비되면 콜백이나 프로미스 등을 통해 처리.)
  자바스크립트 엔진은 싱글 스레드로 동작하기 때문에 한 번에 하나의 작업만 실행.
  하지만 (브라우저나 Node.js가 제공하는 Web API와) 이벤트 루프 덕분에 비동기 처리가 가능.

- 이벤트 루프는 콜 스택이 비었는지 확인하고, 전부 비워지면 마이크로태스크 큐(Promise 등)에 있는 태스크들을 먼저 콜스택으로 가져오고 마찬가지로 마이크로태스크 큐가 전부 비워지면 태스크 큐(setTimeout, 이벤트 핸들러 등)에 쌓인 콜백을 스택으로 가져와 동기와 비동기가 함께 동작할 수 있도록 보장.

#### 마크로 태스크 큐와 마이크로 태스크 큐에 대해 설명해주세요.

- 자바스크립트의 비동기 처리는 이벤트 루프를 통해 이루어지고, 이때 작업은 매크로태스크 큐와 마이크로태스크 큐로 나뉜다.
- 마이크로태스크 큐에는 Promise.then, catch, finally, queueMicrotask, MutationObserver 같은 작업이 들어감
  이벤트 루프는 매크로태스크를 실행하기 전에, 항상 마이크로태스크 큐를 먼저 모두 비워 처리
  즉, 실행 우선순위는 마이크로태스크가 매크로태스크보다 높다. 그래서 예를 들어 Promise.then은 setTimeout보다 항상 먼저 실행.
- 매크로태스크 큐에는 setTimeout, setInterval 등 비동기 함수의 콜백 함수나 이벤트 핸들러 같은 작업이 들어간다.
  이벤트 루프는 콜 스택이 비워지면 매크로태스크 큐에서 한 번에 하나씩 꺼내 콜스택으로 옮김.

#### 브라우저 렌더링 과정을 설명해주세요.

- 브라우저는 HTML과 CSS를 파싱해 DOM과 CSSOM을 만들고, 이를 합쳐 Render Tree를 구성
  이후 Layout 단계에서 크기와 위치를 계산하고, Paint 단계에서 픽셀로 그린 뒤, Composite 단계에서 레이어를 합성해 최종 프레임을 화면에 출력
