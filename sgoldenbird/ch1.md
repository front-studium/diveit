# Ch1. 리액트 개발을 위해 꼭 알아야 할 자바스크립트

## 1.0 왜 리액트인가?

- 단방향 바인딩만 지원 (Angular는 양방향 바인딩) → 데이터의 흐름이 한쪽으로만 간다.
- 기존 자바스크립트 문법에 HTML을 약간 가미한 수준으로 배우기 쉽고 간결.
  (Angular의 경우 뷰를 포현하기 위해 문자열 템플릿 사용, ngIf처럼 Angular 전용 문법 익혀야 함)
- 단순히 UI를 위한 라이브러리로만 작동함으로써 그 역할에 제한을 두고 그 외 모든 것에 자유도를 둠.
  개발자들이 리액트를 기반으로 다양한 것을 시도하면서 커다란 커뮤니티를 얻게 됨.

### 단방향 vs 양방향

- 단방향 바인딩은 항상 변화를 감지하고 업데이트하는 코드를 매번 작성해야 한다. 코드 규모 증가.
- 양방향으로 바인딩되면 뷰의 변화가 컴포넌트에 영향을 미칠수도, 컴포넌트의 상태 변화가 뷰에 영향을 미칠수도 있다. 코드의 규모가 커질수록 상태 변화가 무엇으로 인해 일어났는지 파악하기 어려움.

## 1.1 자바스크립트의 동등 비교

- 객체와 배열은 내부에 값이 존재하는지 여부와 상관없이 truthy로 취급된다.
- 자바스크립트 문자열은 원시타입, 변경 불가능.

### undefined vs null

- undefined: 선언되었지만 할당되지 않은 값
- null: 명시적으로 비어 있음을 나타내는 값

### 탬플릿 리터럴

- 백틱을 사용해서 표현
- 줄바꿈이 가능하고 문자열 내부에 표현식을 쓸 수 있다.

### Symbol

- 중복되지 않는 고유한 값
- 심벌 함수를 이용해서만 만들수 있다. `Symbol()`
- 심벌 함수에 같은 인수를 넘겨주더라도 동일한 값으로 인정되지 않는다.
- 동일한 값을 사용하기 위해서는 `Symbol.for()`를 사용한다.

### 객체 타입

- 객체 타입에는 배열, 함수, 정규식, 클래스 등이 있다.
- 객체는 프로퍼티를 삭제, 추가, 수정 할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장된다.
- 값을 복사할 때도 값이 아닌 참조를 전달하게 된다.

### Object.is

- 리액트에서 사용하는 동등비교는 Object.is다.
- 리액트는 Object.is를 기반으로 동등 비교를 하는 shallowEqual이라는 함수를 만들어 사용
- 리액트는 Object.is로 먼저 비교를 수행한 다음, shallowEqual로 Object.is에서 못하는 객체 간 얕은 비교를 한번 더 수행(1 depth)

### === 와 차이

- ==는 강제 형변환 후 비교

```js
-0 === +0; //true
Object.is(-0, +0); //false

Number.NaN === NaN; //false
Object.is(Number.NaN, NaN); //true

NaN === 0 / 0; //false
Object.is(NaN, 0 / 0); //true
```

- 왜 굳이 구분할까?

  - 몇몇 수학적 연산이나 부동소수점 연산에서 차이가 있기 때문

  ```js
  1 / +0; // Infinity
  1 / -0; // -Infinity
  ```

- 왜 0/0은 NaN일까?
  - 어떤 경우에는 0/0이 1처럼 보일 수 있고, 어떤 경우에는 무한대, 어떤 경우에는 다른 값… 즉 일관된 하나의 값으로 정의할 수 없기 때문에 JS는 NaN처리

### 호환성 도구(compatibility tools)

#### Polyfill

- 브라우저(혹은 런타임)가 지원하지 않는 기능을 흉내내어 똑같이 동작하게 만든 코드
- 구형 환경에서도 최신 기능을 쓸 수 있게 해주는 일종의 보완 코드

#### Transpiler

- 최신 자바스크립트 문법을 구형 자바스크립트 문법으로 변환해주는 도구
- Babel: 자바스크립트의 최신 문법을 다양한 브라우저에서도 일관적으로 지원할 수 있도록 코드를 트랜스파일. (최신 → ES5)

## 1.2 함수

- 함수란 작업을 수행하거나 값을 계산하는 등의 과정을 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것.
- 표현식: 무언가 값을 산출하는 구문
- 일급객체:
  다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체. 즉, 보통 함수나 객체가 다른 일반 값들과 똑같이 취급될 수 있는지를 판별하는 개념.
  자바스크립트 함수는 일급 객체. 함수는 다른 함수의 매개변수, 반환값, 할당도 가능.
- 이름을 가진 함수 리터럴은 코드 문맥에 따라 선언문으로도, 표현식으로도 사용될 수 있다.

#### 런타임

- 코드가 실제로 실행되는 환경
- 프로그래밍 언어의 코드는 그냥 텍스트일 뿐이고, 이게 실행되려면 엔진, 라이브러리, API, 메모리 관리 시스템 같은 실행 환경이 필요. 이 실행 환경 전체를 통틀어 런타임이라고 부른다.
- 자바스크립트 런타임 (브라우저) → 아래 전체가 자바스크립트 브라우저 런타임 환경
  - V8 엔진(코드 해석/실행)
  - Web API (setTimeout, DOM, fetch 등)
  - 이벤트 루프(Event Loop) + 태스크 큐/마이크로태스크 큐
- Node.js 런타임 → 서버 사이드에서 JS를 실행할 수 있게 만드는 런타임
  - V8 엔진
  - Node.js API (fs, http, crypto 등)
  - 이벤트 루프(libuv 기반)
- Java 런타임 (JRE) → 자바 프로그램 실행 환경
  - JVM + 표준 라이브러리

### 함수 표현식과 선언문의 차이 - 호이스팅

- 함수 호이스팅:
  함수 선언문이 마치 코드 맨 앞단에 작성된 것처럼 작동하는 자바스크립트 특징.
  함수에 대한 선언을 실행 전에 미리 메모리에 등록.
- 변수 호이스팅:
  함수 표현식은 함수를 변수에 할당했기 때문에 변수 호이스팅 발생.
  - `var` vs `let, const`:
    함수 호이스팅과 다르게 호이스팅 되는 시점에(런타임 이전에) var의 경우 undefined로 초기화.
    let, const는 TDZ

### 화살표 함수

- 생성자 함수로 화살표 함수를 사용할 수 없다.
- arguments가 존재하지 않는다.
- 화살표 함수는 함수 자체의 바인딩을 갖지 않는다.
- 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 따르게 된다.
- 별도의 작업을 추가로 하지 않고 this에 접근할 수 있는 방법이 바로 화살표 함수.

### this 바인딩

- 함수가 어떻게 호출되냐에 따라 동적으로 결정되는 자기 참조 변수
  - 전역에서 일반함수로 호출 → 전역 객체
  - 객체의 메소드로 호출 → 호출한 객체
  - new 키워드로 호출 → 새로 생성된 인스턴스
  - 이벤트 핸들러 → 이벤트가 발생한 DOM요소
  - 화살표 함수는 호출 방식과 무관하게 선언될 당시 상위 스코프의 this
  - 명시적으로 특정 객체를 this에 바인딩하고 싶다면 bind, call, apply 같은 메소드 사용

### 즉시 실행 함수(IIFE)

- 함수를 정의하고 그 순간 즉시 실행되는 함수.
- 단 한번만 호출되고 다시는 호출 할 수 없다.
- 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프를 운용할 수 있다. 즉시 실행 함수 내부에 있는 값은 그 함수 내부가 아니고서는 접근이 불가능 하기 때문.

### 고차 컴포넌트

- 함수 컴포넌트를 인수로 받아 새로운 함수 컴포넌트를 반환한다.
- 컴포넌트 내부에서 공통으로 관리되는 로직을 분리해 관리할 수 있다.

### 순수함수와 함수의 부수효과

- 함수의 부수효과: 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것
- 순수 함수: 부수효과 없는 함수. 동일한 인수를 받으면 항상 동일한 결과를 반환 → 예측가능, 안정적
- 부수효과는 피할 수 없지만 최소화.
  - API 호출 → HTTP request로 서버 상태를 바꾸거나(POST/PUT/DELETE) 외부 상태에 의존해 결과가 달라질 수 있음(GET)
  - console.log → 브라우저 콘솔 창이라는 외부에 영향
- 부수효과를 처리하는 useEffect 훅의 작동을 최소화 → 함수의 역할을 좁히고 버그를 줄이고 컴포넌트의 안정성을 높임

### 함수를 만들 때 주의해야 할 사항

- 함수의 부수 효과를 최대한 억제하라
- 하나의 함수가 너무 많은 역할을 하지 않도록 작게 만들어라
- 누구나 이해할 수 있는 이름
  - useEffect 등 훅에 넘겨주는 콜백 함수에 네이밍하면 디버깅과 가독성 향상

## 1.3 클래스

- 특정한 형태의 객체를 반복적으로 만들기 위한 일종의 템플릿
- 프로토타입 체이닝: 직접 객체에서 선언하지 않았음에도 프로토타입에 있는 메서드를 찾아서 실행을 도와주는 것
- 클래스가 작동하는 방식은 자바스크립트의 프로토타입을 활용하는 것
- 정적 메서드 내부의 this는 클래스로 생성된 인스턴스가 아닌 클래스 자신을 가리키기 때문에 클래스 명으로 접근
  - 객체를 생성하지 않아도 여러곳에서 재사용이 가능하기 때문에 전역에서 사용하는 유틸함수를 정적 메서드로 많이 활용

## 1.4 클로저

- 부수 효과가 없고 순수해야 한다는 목적을 달성하기 위해 적극적으로 사용된다.
- 선언된 어휘적 환경: 변수가 코드 내부에서 어디서 선언됐는지.
- 함수 컴포넌트의 구조와 작동 방식, 훅의 원리, 의존성 배열 등 함수 컴포넌트의 대부분의 기술이 모두 클로저에 의존.
- 리액트가 관리하는 내부 상태값은 리액트가 별도로 관리하는 클로저 내부에서만 접근할 수 있다.
- 전역 스코프는 누구든 접근할 수 있고 수정할 수 있다.
- 클로저를 활용하면 전역 스코프의 사용을 막고 개발자가 원하는 정보만 개발자가 원하는 방향으로 노출시킬 수 있다.
- 활용 예시

  - `useState`도 클로저. state가 저장돼 있는 어딘가를 기억하기 때문에 계속 state값 사용 가능.
  - `useState`의 변수를 저장해 두고, 변수 접근 및 수정은 클로저 내부에서 확인이 가능해 값이 변하면 렌더링 함수를 호출.
  - innerFunction이 선언된 어휘적 환경, 즉 outerFunction에는 x가는 변수가 존재하며 반환된 innerFunction에서는 x라는 변수가 존재하던 환경을 기억한다.

  ```js
  function outerFunction() {
    var x = "hello";
    function innerFunction() {
      console.log(x);
    }

    return innerFunction;
  }

  const innerFunction = outerFunction();
  innerFunction(); // "hello"
  ```

  - counter 변수를 직접적으로 노출하지 않음으로써 사용자가 직접 수정하는 것을 막고, 접근하는 경우를 제한해 로그를 남길 수도 있음
  - counter 변수의 업데이트를 increase와 decrease로 제한해 무분별하게 변경되는 것을 막음

  ```js
  function Counter() {
    var counter = 0;

    return {
      increase: function () {
        return ++counter;
      },
      decrease: function () {
        return --counter;
      },
      counter: function () {
        console.log("counter에 접근!");
        return counter;
      },
    };
  }

  var c = Counter();
  ```

- 주의: 클로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 추가 비용이 든다. (메모리 저장 용량에 영향). 적절한 스코프로 가둬야함.

### 스코프

- 자바스크립트는 기본적으로 함수 레벨 스코프. 즉, { }블록이 스코프 범위를 결정하지 않는다.
- 자바스크립트에서 스코프는 일단 가장 가까운 스코프에서 변수가 존재하는지를 먼저 확인.

## 1.5 이벤트 루프와 비동기 통신의 이해

- 자바스크립트는 싱글 스레드, 동기 방식으로 작동
- 프로세스
  - 프로그램을 구동해 프로그램의 상태가 메모리상에서 실행되는 작업 단위
  - 하나의 프로그램 실행은 하나의 프로세스를 가지고 그 프로세스 내부에서 모든 작업이 처리

### 스레드 vs 동기

- 스레드
  - CPU가 작업을 수행하는 실행단위. 프로세스보다 더 작은 실행단위
  - 하나의 프로세스에는 여러 개의 스레드를 만들수 있다.
  - 스레드 끼리는 메모리를 공유할 수 있어 여러 작업을 동시에 수행할 수 있다.
  - 스레드는 하나의 프로세스에서 동시에 서로 같은 자원에 접근해 여러번 수정하는 등 동시성 문제가 발생할수 있다.
  - 각각 격리되어있는 프로세스와 달리 하나의 스레드가 문제 생기면 같은 자원을 공유하는 다른 스레드에도 동시에 문제 발생
  - 싱글스레드: 한번에 하나의 작업만 처리하는 구조
  - 멀티스레딩은 메모리 공유로 인해 동시에 같은 자원에 접근 하면 타이밍 이슈 발생.
  - 멀티스레딩 환경: Node.js Worker, 브라우저 WebWorker
- 동기/비동기
  - 작업 순서
  - 동기: 순차적, 기다림. 요청이 시작된 후에는 무조건 응답을 받은 후에야 비로소 다른 작업 처리할 수 있다.
  - 비동기: 비동기 함수 선언 시 쓰는 async. 응답이 오건 말건 다음 작업이 이루어진다.
  - 자바스크립트가 싱글스레드임에도 비동기 처리가 가능한 것은 이벤트 루프 덕분이다.

### 이벤트 루프

- 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치
- 콜스택: 자바스크립트에서 수행해야할 코드나 함수를 순차적으로 담아두는 스택
- 이벤트 루프는 호출 스택이 비어있는지 확인.
- 코드를 실행하는 것과 호출 스택이 비어있는지 확인하는 것 모두 단일 스레드에서 일어남. 즉, 두 작업은 동시에 일어날 수 없으며 한 스레드에서 순차적으로 일어남.

```js
function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

function foo() {
  console.log("foo");
  setTimeout(bar(), 3000);
  baz();
}

foo();
```

- setTimeout → 동기적으로 작동.
- 콜백 bar() → 비동기적으로 작동.
- JS엔진이 콜스택에서 setTimeout 실행 → 브라우저(WebAPIs영역)에게 타이머 작업 위임 → setTimeout완료, 다음 작업 실행
- 타이머 카운트다운은 브라우저가 실행 → 브라우저(WebAPI)가 타이머를 돌려 일정 시간(3000)이 지나면 콜백을 태스크 큐에 넣음
- 이벤트 루프가 콜스택이 완전히 비면 태스크 큐에서 콜백을 콜스택으로 가져옴
- 콜백함수 실행은 콜스택에서 자바스크립트 엔진이 수행

#### Web API

- 브라우저가 자바스크립트에 제공하는 API
- 자바스크립트 자체에는 없는 기능을 브라우저가 추가 기능으로 제공해서, 예를 들어 DOM 조작, 비동기 타이머, 네트워크 통신 같은 작업을 할 수 있습니다.
- 즉, 웹 애플리케이션이 브라우저 환경과 상호작용할 수 있도록 하는 인터페이스라고 할 수 있습니다.
- 자바스크립트 자체만으로는 브라우저나 OS에 접근할 방법이 없기 때문에 브라우저가 Web API를 제공하고, 자바스크립트는 이걸 이용해:
  - DOM 조작
  - 이벤트 처리
  - 네트워크 통신
  - 파일 시스템 접근
  - 디바이스 기능 활용(GPS, 카메라, 마이크 등)
- 대표적인 Web API 예시
  - DOM API: document.querySelector(), element.addEventListener()
  - Timer API: setTimeout(), setInterval()
  - Network API: fetch(), XMLHttpRequest
  - Storage API: localStorage, sessionStorage, IndexedDB
  - Worker API: Web Worker, Service Worker
  - 기타: Canvas API, Geolocation API, WebRTC, Web Audio API 등

### 태스크 큐(마크로 큐, 이벤트 큐), 마이크로 태스크 큐

#### 태스크 큐

- 비동기 함수의 콜백 함수나 이벤트 핸들러 등
- 이벤트 루프는 태스크 큐를 한 개 이상 가지고 있다.
- 태스크 큐는 자료 구조의 큐가 아니고 set 형태를 띄고 있다. 선택된 큐 중에서 실행 가능한 가장 오래된 태스크를 가져와야 하기 때문이다.
- 자료 구조 큐: FIFO
- 메인 스레드가 아닌 태스크 큐가 할당되는 별도의 스레드에 작업을 할당해 브라우저나 Node.js가 수행

#### 마이크로 태스크 큐

- 이벤트 루프는 하나의 마이크로 태스크 큐를 갖고 있다. Promise
- 태스크 큐보다 우선. 마이크로 태스크 큐가 빌 때까지 태스크 큐의 실행은 뒤로 미뤄진다.
- 동기 → micro task → requestAnimationFrame → 브라우저 렌더링 → macro task
  - 마이크로 태스크를 실행한 뒤에 렌더링이 일어난다. 각 마이크로 태스크 큐 작업이 끝날때마다 한번씩 렌더링할 기회를 얻게 된다.
  - 동기 코드는 물론이고 마이크로 태스크 또한 렌더링에 영향을 미칠 수 있다.
  - 마이크로 태스크는 렌더링 보다 우선이고 큐가 빌때까지 연속실행. 그 사이에는 화면이 갱신되지 않는다. 그래서 동기처럼 밀리고 한번에 끝난 후 갱신.

#### rAF (vs setTimeout)

- requestAnimationFrame(rAF)은 브라우저가 다음 프레임을 그리기 직전에 특정 콜백 함수를 실행하도록 예약하는 API
- rAF를 쓰면 브라우저의 렌더링 주기와 맞춰서 애니메이션을 최적화
- requestAnimationFrame은 브라우저에 다음 리페인트 전에 콜백 함수 호출을 가능하게 한다.
- 보통 60fps(16.7ms 간격)로 동작하는 디스플레이에 맞춰 최적의 타이밍에 실행되므로, 애니메이션이 부드럽습니다.
- 반면 setTimeout(fn, 16) 같은 방식은 정확히 16ms마다 실행된다고 보장되지 않는다. 브라우저 리페인트 시점과 어긋날 수 있어서 티어링(끊김) 같은 현상이 생긴다.
- rAF는 탭이 비활성화되거나 브라우저가 백그라운드로 가면 자동으로 중단되거나 느려짐. 즉, 불필요한 CPU 자원 소모를 막음 → 배터리 절약, 성능 최적화에 유리.
- setTimeout은 브라우저가 알아서 최적화하지 않으면 계속 돌아갈 수 있음.

#### 프레임

- 프레임은 사용자가 보는 화면의 한 "정지된 그림". 렌더링의 결과물.
- 애니메이션이나 동영상은 사실 정지 그림(프레임)을 아주 빠르게 연속해서 보여주는 것일 뿐이다. 에니메이션은 렌더링의 반복.
- 60fps → 1초에 정지 그림 60장을 보여줌
- 120fps → 1초에 정지 그림 120장을 보여줌
- 브라우저는 프레임을 짧은 간격(보통 16.7ms)으로 계속 만들어내서 갱신
- 브라우저가 한 프레임을 만드는 과정은 보통 이렇게 흘러감
  - 자바스크립트 실행 (JS): DOM 변경, 스타일 변경, 좌표 이동 같은 작업이 일어남.
  - 스타일 계산 (Style): 어떤 CSS가 적용되는지 다시 계산.
  - 레이아웃 (Layout): 요소의 크기와 위치를 다시 배치.
  - 페인트 (Paint): 실제 픽셀 단위로 색칠.
  - 합성 (Composite): 여러 레이어를 합쳐 최종 그림(프레임) 완성.
    <br/>이 “최종 그림”이 바로 프레임이고, 그게 모니터에 출력. 렌더링 과정이 프레임을 만들어내는 과정.

## 1.6 리액트에서 자주 사용하는 자바스크립트 문법

- 현재 Edge는 chromium 기반, 크롬과 거의 같다.

### 구조 분해 할당

배열, 객체의 값을 분해해 개별 변수에 즉시 할당하는 것

#### 배열 구조 분해 할당

- `useState`
- 변수 이름 자유롭게 선언
- undefined일 때만 기본값 사용
- 전개 연산자는 앞에서 사용 불가 (...rest)

#### 객체 구조 분해 할당

- 변수 이름은 객체 내부 이름 사용
- 객체 내부 키와 이름이 다르면 새로운 이름으로 다시 할당
- computed property name `[]` : 변수나 표현식을 [ ]안에 넣어서 동적으로 키 이름 결정

```js
const {age} = user; 도 const {age:age} =user; 가 축약된것

const {[key]} = object // SayntaxError
```

- [key]는 어떤 속성을 꺼낼지는 알려주지만 꺼낸 값을 어떤 변수에 담을지는 알려주지 않음. 그래서 : 뒤에 직접 변수명을 지정해야 함.

### 전개 구문

- 배열이나 객체, 문자열 같이 순회할 수 있는 값에 대해 전개
- iterable: 내부에 Symbol.iterator 메서드를 가지고 있어서 iterator를 반환할 수 있는 객체
- iterator는 next()를 호출하면 {value, done} 형태로 값을 하나씩 내놓는다.
- 객체 전개 구문에 있어서는 순서가 중요하다. 키와 값으로 이루어져 있어 덮어쓰일수 있기 때문.

### 객체 초기자 (object shorthand assignment)

- 객체를 선언할 때 객체에 넣고자 하는 키와 값을 가지고 있는 변수가 이미 존재한다면 간결하게 `a: a` 대신 `a`만 써도 된다.

### Array 프로토타입 메서드: map, filter, reduce, forEach

- 기존 배열의 값을 건드리지 않고 새로운 값을 만든다.

#### Array.prototype.map

- 배열의 각 아이템을 순회하며 각 아이템을 콜백으로 연산한 결과로 구성된 똑같은 길이의 새로운 배열 반환

#### Array.prototype.filter

- 콜백함수에서 truthy조건을 만족하는 경우에만 해당 원소를 반환

#### Array.prototype.reduce

- 콜백함수와 초깃값을 인수로 받음
- 콜백함수 반환값을 초깃값에 누적
- 합계 뿐 아니라 배열을 하나의 객체로 변환하는 등 활용

#### Array.prototype.forEach

- 배열을 순회하면서 단순히 그 콜백함수를 실행하기만 한다.
- forEach는 아무런 반환값이 없고, undefined다.
- 에러를 던지거나 프로세스를 종료하지 않는 이상, 멈출 수 없다. break, return, 그 무엇을 이요해도 배열 순회를 멈출 수 없다.
- forEach내부의 콜백함수는 무조건 0(n)만큼 실행

## 1.7 선택이 아닌 필수, 타입스크립트
